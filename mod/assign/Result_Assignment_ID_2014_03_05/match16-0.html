<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>Muhammad Faiq_Farhan_Faiq Farhan(4518).cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>Muhammad Faiq_Farhan_Faiq Farhan(4518).cpp</CENTER></H3><HR>
<PRE>
//Assignment:1
// Muhammad Faiq Farhan_(04518)_BsCS-3A

#include &lt;stdio.h&gt;		
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
// Reffering Functions
void input (FILE *ptr, char **X, unsigned int Rows, unsigned int Columns);  
void main_logic (char **X , char **Y, unsigned int Rows, unsigned int Columns);
<A NAME="0"></A>void show (char **Colony, unsigned int Rows, unsigned int Columns);
void Neighbors_Checking (char **X , char **Y, unsigned int l, unsigned int m, unsigned int Loop_1_initial, unsigned int Loop_1_limit, unsigned int Loop_2_initial, unsigned int Loop_2_limit );

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match16-1.html#0',3,'match16-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void main_logic (char **X , char **Y, unsigned int Rows, unsigned int Columns)
{
	for (unsigned int l = 0; l &lt; Rows ; l++)		
	{
		for (unsigned int m = 0; m &lt; Columns; m++)				//Copying
		{
			Y[l][m] = X[l][m];</B></FONT>
		}
<A NAME="1"></A>	}
	unsigned int Loop_1_initial,Loop_2_initial,Loop_1_limit,Loop_2_limit;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match16-1.html#1',3,'match16-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	for (unsigned int l = 0; l &lt; Rows; l++)
	{
		for (unsigned int m = 0; m &lt; Columns ; m++)
		{
			
			if((l == 0 &amp;&amp; m &gt; 0) &amp;&amp; m &lt; (Columns-1))		
			{</B></FONT>
				Loop_1_initial = l;								//Topmost Row
				Loop_2_initial = m-1;
				Loop_1_limit = l+1;
				Loop_2_limit = m+1;
				Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
			}
			if((l &gt; 0 &amp;&amp; l &lt; (Rows-1)) &amp;&amp; (m &gt; 0 &amp;&amp; m &lt; (Columns-1)))
			{
				Loop_1_initial = l-1;							//Centre
				Loop_2_initial = m-1;
				Loop_1_limit = l+1;
				Loop_2_limit = m+1;
				Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
			}
			if((l == (Rows-1) &amp;&amp; m &gt; 0) &amp;&amp; m &lt; (Columns-1))		//Bottom Row
			{
				Loop_1_initial = l-1; 
				Loop_2_initial = m-1;
				Loop_1_limit = l;
				Loop_2_limit = m+1;
				Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
			}
											/*For Leftmost Column*/
			if((l &lt; Rows) &amp;&amp; m == 0)				
			{
					if(l == (Rows-1))	
				{												// Element 1 from left of last Row
					Loop_1_initial = l-1; 
					Loop_2_initial = m;
					Loop_1_limit = l;
					Loop_2_limit = m+1;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
				}

				if(l &lt; (Rows-1) &amp;&amp; l &gt; 0) 
				{
					Loop_1_initial = l-1;						//Element 1 in centre of Row
					Loop_2_initial = m;
					Loop_1_limit = l+1;
					Loop_2_limit = m+1;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);

				}
			
				if(l == 0 )			
				{												// Element 1 from left of first Row
					Loop_1_initial = l; 
					Loop_2_initial = m;
					Loop_1_limit = l+1;
					Loop_2_limit = m+1;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
				}
			}
											/*For Rightmost Column*/
			if((l &lt; Rows) &amp;&amp; m == (Columns-1))		
			{
				if(l == 0)	
				{
					Loop_1_initial = l;								//First Row
					Loop_2_initial = m-1;
					Loop_1_limit = l+1;
					Loop_2_limit = m+1;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
				}
				
				if(l &gt; 0 &amp;&amp; l &lt; (Rows-1))	
				{
					Loop_1_initial = l-1; 
					Loop_2_initial = m-1;							//Middle Row
					Loop_1_limit = l+1;
					Loop_2_limit = m;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
				}
				
				if(l == (Rows-1))	
				{
					Loop_1_initial = l-1;							//Last Row
					Loop_2_initial = m-1;
					Loop_1_limit = l;
					Loop_2_limit = m;
					Neighbors_Checking (X, Y, l, m, Loop_1_initial, Loop_1_limit, Loop_2_initial, Loop_2_limit);
				}
			}
		}
	}
	for (unsigned int l = 0; l &lt; Rows ; l++)
	{
		for (unsigned int m = 0; m &lt; Columns; m++)					//Copying Again
		{
			X[l][m] = Y[l][m];
		}
<A NAME="2"></A>	}
}

<FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match16-1.html#2',3,'match16-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void show (char **Colony, unsigned int Rows, unsigned int Columns)			// To show Patterns
{
	printf(&quot;\n\n&quot;);
	for (unsigned int l = 0; l &lt; Rows ; l++)
	{
<A NAME="3"></A>		for(unsigned int m=0; m &lt; Columns; m++) 
		{</B></FONT>
			printf(&quot;%c&quot;,Colony[l][m]);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match16-1.html#3',3,'match16-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		}
		printf(&quot;\n&quot;);
	}
}

void Neighbors_Checking (char **X , char **Y, unsigned int l, unsigned int m, unsigned int Loop_1_initial, unsigned int Loop_1_limit, unsigned int Loop_2_initial, unsigned int Loop_2_limit )
{
	unsigned int count = 0;
	for (unsigned int a = Loop_1_initial; a &lt;= Loop_1_limit; a++)
	{
		for (unsigned int b = Loop_2_initial; b &lt;= Loop_2_limit; b++)
		{
			if(a == l &amp;&amp; b == m)									// Checking Neighbors</B></FONT>
			{
				continue;
			}
			if(X[a][b] == '-') 
<A NAME="4"></A>			{
				continue;
			}
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match16-1.html#4',3,'match16-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			if(X[a][b] == 'X') 
			{
				count++;
				continue;
			}
		}
	}
												/*Births and Deaths Of Cells*/
	if(count &lt;= 1) 
	{
		Y[l][m] = '-';
	}
	if(count == 2) 
	{</B></FONT>
	}
	if(count == 3) 
	{
		Y[l][m] = 'X';
	}
<A NAME="5"></A>	if(count &gt;= 4) 
	{
		Y[l][m] = '-';
<FONT color="#c8c2a7"><A HREF="javascript:ZweiFrames('match16-1.html#5',3,'match16-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}
}

void input (FILE *ptr, char **X, unsigned int Rows, unsigned int Columns)
{
	while (!feof(ptr))												//Reading from a Text File
	{
		for (unsigned int l = 0; l &lt; Rows; l++)
		{
			for (unsigned int m = 0; m &lt; Columns; m++)
			{
				fscanf(ptr,&quot;%c&quot;,&amp;X[l][m]); 
			}
			fscanf(ptr,&quot;\n&quot;);
		}
	}
}</B></FONT>

int main (void)
{
<A NAME="6"></A>	FILE *ptr;
	unsigned int Rows = 0, Columns = 0;

<FONT color="#50ebec"><A HREF="javascript:ZweiFrames('match16-1.html#6',3,'match16-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	char Name_Of_File[20];
	printf(&quot;Welcome to a simulation of the lifecycle of a bacteria colony.\nCells (X) live and die by the following rules:\n- A cell with 1 or fewer neighbors dies.\n&quot;);
	printf(&quot;- Locations with 2 neighbors remain stable.\n- Locations with 3 neighbors will create life.\n- A cell with 4 or more neighbors dies.&quot;);
	printf(&quot;\n\nGrid input file name? &quot;);
	gets (Name_Of_File);

	ptr = fopen(Name_Of_File,&quot;r&quot;);										//Opening a File
	if(ptr == NULL)	
	{
		printf(&quot;No File found with this name.\nPress any key to exit&quot;);
		exit (0);
	} 
	fscanf(ptr,&quot;%d\n%d\n&quot;,&amp;Rows,&amp;Columns);

	char **X = (char **) malloc (sizeof(char *) * Rows);			//Allocating 2-D Dynamic Memory for Arrays
	for (unsigned int l = 0; l &lt; Rows; l++)	
	{
		X[l] = (char *) malloc (sizeof(char) * Columns);
	}

	char **Y = (char **) malloc (sizeof(char *) * Rows);			//2-D Array for storing New Pattern
	for (unsigned int l = 0; l &lt; Rows; l++)	
	{
		Y[l] = (char *) malloc (sizeof(char) * Columns);
	}</B></FONT>

	input(ptr,X, Rows, Columns);									// Input Function
	show (X, Rows, Columns);										// Show Function
	while (1) 
	{
		char opt;	
		printf(&quot;t)ick, q)uit? &quot;);
		std::cin&gt;&gt;opt;
		if (opt == 't')
		{
			main_logic (X, Y, Rows, Columns);						//Main Logic Function
			show (X, Rows, Columns);								// Show Function
		}
		else if (opt == 'q')
			break;
	}
	delete (X);														//De Allocating Memories
	delete (Y);

	return 0;
}
</PRE>
</BODY>
</HTML>
